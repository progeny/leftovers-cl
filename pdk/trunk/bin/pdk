#!/usr/bin/python
#   Copyright 2005 Progeny Linux Systems, Inc.
#
#   This file is part of PDK.
#
#   PDK is free software; you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   PDK is distributed in the hope that it will be useful, but WITHOUT
#   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
#   License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with PDK; if not, write to the Free Software Foundation,
#   Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

"""
pdk

This is the command line controller for all pdk.
"""

__revision__ = '$Progeny$'

import cmd
import os
import sys
import traceback
import pdk.log as log
from pdk.util import assert_python_version
assert_python_version()

from warnings import filterwarnings
from pdk.exceptions import CommandLineError, InputError, \
                    SemanticError, ConfigurationError, \
                    IntegrityFault
logger = log.get_logger()

## pdk.py
## Author:  Glen Smith
## Date:    15 April 2005
## Version: 0.0.1


def _get_args_as_list(args):
    """
    If a command is invoked from the command line,
    the args will be one string.
    If the command is invoked from the pdk
    command environment, the args will be a list.
    This utility function returns a list for either
    so you don't have to care
    """
    if type(args) == type(''):
        return args.split()
    elif type(args) == type([]):
        return args
    else:
        print "unexpected args is ", type(args)


class LazyModuleRef(object):
    """Callable object that defers importing a package until it is 
    actually needed by a function call.

    This prevents us having to import all modules we want to reference, 
    whether we need them or not, and without the workaround of writing 
    a local function to import each module on demand.
    """
    def __init__(self, module, func_param):
        self.module = module
        self.function = func_param
    def __call__(self, *args, **kwargs):
        # Note: if modules NOT in 'pdk' are needed, then add the add'l
        #       modules to the fromlist (final argument to __import__)
        module = __import__(self.module, globals(), locals(), ["pdk"])
        fn = getattr(module, self.function)
        return fn(_get_args_as_list(*args), **kwargs)
    def getdoc(self):
        """Trick to get docstring from mapped fuction"""
        module = __import__(self.module, globals(), locals(), ["pdk"])
        fn = getattr(module, self.function)
        return fn.__doc__
    __doc__ = property(getdoc, None)


class Pdk(cmd.Cmd):
    """This is the main command object"""

    do_audit = LazyModuleRef('pdk.audit','audit')
    do_cachepush = LazyModuleRef('pdk.cache', 'do_cachepush')
    do_cachereceive = LazyModuleRef('pdk.cache', 'do_cachereceive')
    do_cachepull = LazyModuleRef('pdk.component', 'do_cachepull')
    do_init = LazyModuleRef('pdk.services', 'init')
    do_publish = LazyModuleRef('pdk.source', 'publish')
    do_update = LazyModuleRef('pdk.workspace', 'update')
    do_commit = LazyModuleRef('pdk.workspace', 'commit')
    #need to rename
    do_add = LazyModuleRef('pdk.workspace', 'add')
    do_clone = LazyModuleRef('pdk.workspace', 'clone')
    ##do_checkin = LazyModuleRef('pdk.version_control', 'checkin')
    ##do_copy = LazyModuleRef('pdk.version_control', 'copy')
    do_repogen = LazyModuleRef('pdk.repogen','generate')
    do_dumpmeta = LazyModuleRef('pdk.component', 'do_dumpmeta')
    #obsolete
    do_mark = LazyModuleRef('pdk.mark','mark')
    do_semdiff = LazyModuleRef('pdk.semdiff', 'do_semdiff')
    do_resolve = LazyModuleRef('pdk.component', 'resolve')
    do_download = LazyModuleRef('pdk.component', 'download')
    #temporary utility
    do_production_pull = LazyModuleRef('pdk.workspace', 'pull')


    def __init__(self):
        """
        Set up the command dictionary for pdk
        """
        cmd.Cmd.__init__(self)
        self.prompt = "pdk=>> "
        self.intro  = "Welcome to pdk!"  ## defaults to None
        self._hist    = []      ## No history yet
        self._locals  = {}      ## Initialize execution namespace for user
        self._globals = {}


    def _is_in_shell(self):
        """invoke to assure commands aren't being called from a script"""
        ret_val = False
        stack = traceback.extract_stack()
        for entry in stack:
            if "cmdloop" in entry:
                ret_val = True
                break
        return ret_val
    
    ## Command definitions ##
    def do_hist(self, args):
        """Print a list of commands that have been entered"""
        if args:
            raise CommandLineError, "hist command takes no arguments"
        if self._is_in_shell():
            print self._hist


    def do_exit(self, args):
        """Exits from the pdk command shell"""
        if args:
            raise CommandLineError, "exit command takes no arguments"
        return -1


    def do_quit(self, args):
        """Exits from the pdk command shell"""
        if args:
            raise CommandLineError, "quit command takes no arguments"
        return -1


    def do_compare(self, args):
        """
        compare an upstream repo to local components
        """
        import pdk.compare as compare
        results = compare.compare_to_debian_repo(args[0], args[1:])
        for result in results:
            print "|".join(result)


    def module_command(self, module, args):
        """
        Provide a general function that supports
        commands of the form
        pdk object command [args]
        """
        if args:
            arg_list = _get_args_as_list(args)
            if hasattr(module, arg_list[0]):
                mod_func = getattr(module, arg_list[0])
                mod_func(arg_list[1:])
            else:
                print "nope"
        else:
            print "What do you want to do with " + \
                   module.__name__ + " ?"


    def do_workspace(self, args):
        """
        Perform an action on a workspace
        General usage:
        pdk workspace command args
        """
        from pdk import workspace
        self.module_command(workspace, args)

 
    def do_channel(self, args):
        """
        Perform an action on channel(s)
        General usage:
        pdk channel command args
        """
        from pdk import channels
        self.module_command(channels, args)

 
    def do_package(self, args):
        """
        Perform an action on a package
        General usage:
        pdk package command args
        Specialized for
        pdk package add
        """
        from pdk import package
        if args:
            arg_list = _get_args_as_list(args)
            if arg_list[0] == "add":
                from pdk import add
                add.add(arg_list[1:])
            else:
                self.module_command(package, args)
        else:
            print "What do you want to do with a package?"

    
    def module_help(self, module, args):
        """
        Provide a general function that supports help for
        commands of the form
        pdk help object command [args]
        """
        arg_list = args
        if hasattr(module, 'help_' + arg_list[0]):
            help_func = getattr(module, 'help_' + arg_list[0])
            help_func(arg_list[1:])
        elif hasattr(module, arg_list[0]):
            doc = getattr(module, arg_list[0]).__doc__
            if doc:
                self.stdout.write("%s\n"%str(doc))
            else:
                self.stdout.write("%s\n"%str(self.nohelp % (arg_list[0],)))
        else:
            self.stdout.write("%s\n"%str(self.nohelp % (arg_list[0],)))


    def help_workspace(self, *args):
        """
        Dispatch help requests for commands of the form
        pdk help workspace command args
        """
        if args:
            arg_list = args[0]
            from pdk import workspace
            self.module_help(workspace, arg_list)
        else:
            print self.do_workspace.__doc__


    ## Command definitions to support Cmd object functionality ##

    def do_EOF(self, args):
        """Exit on system end of file character"""
        print ""
        return self.do_exit(args)


    def do_shell(self, args):
        """Pass command to a system shell when line begins with '!'"""
        os.system(args)


    def do_help(self, args):
        """Get help on commands
           'help' or '?' with no arguments prints a list of commands for which help is available
           'help <command>' or '? <command>' gives help on <command>
        """
        if args:
            arg_list = _get_args_as_list(args)
            if len(arg_list) > 1 and hasattr(self, 'help_' + arg_list[0]):
                help_func = getattr(self, 'help_' + arg_list[0])
                help_func(arg_list[1:])
            else:
                cmd.Cmd.do_help(self, arg_list[0])
        else:        
            cmd.Cmd.do_help(self, args)


    ## Override methods in Cmd object ##
    def preloop(self):
        """Initialization before prompting user for commands.
           Despite the claims in the Cmd documentaion, Cmd.preloop() is not a stub.
        """
        cmd.Cmd.preloop(self)   ## sets up command completion


    def postloop(self):
        """Take care of any unfinished business.
           Despite the claims in the Cmd documentaion, Cmd.postloop() is not a stub.
        """
        cmd.Cmd.postloop(self)   ## Clean up command completion
        logger.info("Exiting...")


    def precmd(self, line):
        """ This method is called after the line has been input but before
            it has been interpreted. If you want to modifdy the input line
            before execution (for example, variable substitution) do it here.
        """
        self._hist += [ line.strip() ]
        return line


    def postcmd(self, stop, line):
        """If you want to stop the pdk,
           return something that evaluates to true.
           If you want to do some post command processing, 
           do it here.
        """
        logger.log(stop, line)
        return stop


    def emptyline(self):    
        """Do nothing on empty input line"""
        pass


# Plug-in interface
# 
# Configuration file has <path> <function> <cmdname>
# to create a LazyModuleRef for a plugin command.  
# path      is for __import__, where plugin is located
# function  is name of function to call in plugin
# cmdname   is the name of the local command
#
# ex:   
#   pdk workspace create
#
# As-yet, there is no structure or comment marker for plug-ins
for addin_file in [ x for x in ('~/.pdk_addins','.pdk_addins')
                    if os.path.exists(x) ]:
    for record in open(addin_file):
        path, function, localname  = record.split()
        ref = LazyModuleRef(path, function)
        setattr(Pdk, localname, ref) 


if __name__ == '__main__':
    filterwarnings('ignore', category = FutureWarning)
    main_args = sys.argv or []
    pdk = Pdk()

    # are we being invoked as a cgi?
    if 'GATEWAY_INTERFACE' in os.environ:
        main_args = ['pdk', 'cachereceive', os.environ['PDK_CACHE_PATH'] ]

    if len(main_args) == 1:
        pdk.cmdloop() 
    else:
        fn_name = 'do_%s' % main_args[1]
        try:
            func = getattr(pdk, fn_name)
            func(main_args[2:])
        except IntegrityFault, message:
            logger.error("Integrity Fault Noted: %s" % message)
            sys.exit(1)
        except CommandLineError, message:
            logger.error("Syntax Error: %s" % message)
            pdk.do_help(main_args[0])
            sys.exit(2)
        except InputError, message:
            logger.error("Invalid input: %s" % message)
            sys.exit(3)
        except SemanticError, message:
            logger.error("Operation cannot be performed: %s" % message)
            sys.exit(4)
        except ConfigurationError, message:
            logger.error("Configuration/setup error: %s" % message)
            sys.exit(5)
        except:
            traceback.print_exc(sys.stderr)
            logger.error("Unknown error")
            sys.exit(6)


# vim:ai:et:sts=4:sw=4:tw=0:
